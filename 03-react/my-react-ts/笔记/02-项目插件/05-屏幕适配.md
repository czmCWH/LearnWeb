# 一、基于 postcss-px-to-viewport-8-plugin 屏幕适配

安装：
```shell
$ npm install postcss-px-to-viewport-8-plugin -D
```

vite.config.ts 配置：
```ts
import path from 'node:path'
import postCssPxToViewport from 'postcss-px-to-viewport-8-plugin'

export default defineConfig(({ mode }) => {
  // 获取`.env`环境配置文件
   const env = loadEnv(mode, process.cwd());

  return {
    base: './',
    resolve: {
      alias: {
        '@': path.resolve(__dirname, './src'),
      },
    },
    // 配置 tailwindcss 插件，让项目编译时自动分析类名转换为对应的样式
    plugins: [react(), tailwindcss()],
    css: {
      postcss: {
        plugins: [
          postCssPxToViewport({
            unitToConvert: 'px',    // 需要转换的单位
            viewportWidth: 393,     // 设计稿的视口宽度（通常以 iPhone 6/7/8 为准）
            unitPrecision: 5,       // 转换后保留的小数位数
            propList: ['*'],        // 能转化为 vw 的属性列表
            viewportUnit: 'vw',     // 希望使用的视口单位
            fontViewportUnit: 'vw', // 字体使用的视口单位
            selectorBlackList: ['.ignore-'], // 忽略的 CSS 类名
            minPixelValue: 1,       // 设置最小转换数值，小于 1 则不转换
            mediaQuery: false,      // 是否在媒体查询中也转换 px
            exclude: [/node_modules/], // 忽略 node_modules 目录下的文件
          }),
        ],
      },
    },
  }
});
```

# 二、基于 Tailwind CSS 使用 postcss-pxtorem 插件进行屏幕适配

参考博客：<https://mp.weixin.qq.com/s/tNVgaVgaRE9WYStlAaWivQ>，一种适合H5屏幕适配方案。

Tailwind 默认的 rem 是基于 16px 适配的。使用 postcss-pxtorem 适配时，会存在如下问题：
  - postcss-pxtorem 无法转换 JSX 里的 `style={{ width: '20px' }}` 行内样式；
  - `w-[100px]` 设置自定义大小时，不会被缩放；


## 实现步骤
* 1、安装插件

```shell
# 1、基于 vite 安装 tailwindcss
$ npm install tailwindcss @tailwindcss/vite

# 3、安装 postcss-pxtorem 编译时插件，用于将 px 转换为 rem.
$ npm install -D postcss-pxtorem
```

* 2、配置 `postcss.config.mjs`

```mjs
export default {
  plugins: {
    // "@tailwindcss/postcss": {},
    'postcss-pxtorem': {
      rootValue: 16, // 基准值，对应于根元素的 font-size
      unitPrecision: 5, // 保留小数点位数
      propList: ['*', '!min-width', '!max-width'], // 排除 min-width 和 max-width 属性
      selectorBlackList: [], // 忽略的选择器
      replace: true, // 替换而不是添加备用属性
      mediaQuery: false, // 允许在媒体查询中转换 px
      minPixelValue: 0 // 最小的转换数值
    }
  }
}
```

* 3、添加配置 `setRootFontSize.ts`

```ts
function setRootFontSize(): void {
  const docEl = document.documentElement;
  let clientWidth = docEl.clientWidth;
  if (!clientWidth) return;
  const baseFontSize = 16; // 基准字体大小
  const designWidth = 375; // 设计稿宽度

  const maxWidth = 600;    // 屏幕最大适配宽度
  // 如果屏幕宽度超过 600px，计算字号时锁定为 600px 的比例
  if (clientWidth > maxWidth) {
    clientWidth = maxWidth;
  }

  docEl.style.fontSize = (baseFontSize * (clientWidth / designWidth)) + 'px';
}
export default setRootFontSize;
```

* 4、监听页面变化 `main.tsx`

```ts
// 1. 立即执行一次初始化，设置根元素的字体大小
setRootFontSize();

// 2. 窗口大小改变时重新设置
window.addEventListener('resize', setRootFontSize);
// 移动端建议同时监听横竖屏切换
window.addEventListener('pageshow', (e) => {
  if (e.persisted) setRootFontSize();
});

const root = createRoot(document.getElementById('root')!);
```

* 5、实现“大屏（如 PC 浏览器）显示 600px 并居中，小屏全屏适配
```scss
/* 针对 React 挂载的根节点 */
#root {
  max-width: 600px;
  margin: 0 auto;
  min-height: 100vh;
  background-color: #fff; /* 保证容器背景色，防止两侧留白太突兀 */
  position: relative;
}

/* 如果你的背景色是设置在 body 上的，记得给 body 设置背景色以区分侧边 */
body {
  background-color: #f5f5f5; /* 侧边底色 */
  margin: 0;
}
```


如果你在 PC 端查看时，某些固定定位（Fixed）的元素（如底栏）依然铺满全屏，请确保给这些元素也添加 

```css
.bottom-bar {
  max-width: 600px; 
  left: 50%; 
  transform: translateX(-50%);
}
```
